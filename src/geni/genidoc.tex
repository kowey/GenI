\documentclass[11pt]{report}
%\documentclass{foils}

\usepackage{geometry,graphicx}
\usepackage{verbatim}
\usepackage{url}
\usepackage{html}
\usepackage{fancybox}
\usepackage{fancyhdr}
\usepackage{framed}
\usepackage{color}

\usepackage{covington}  % included with GenI

\geometry{verbose,a4paper,tmargin=40mm,bmargin=40mm,lmargin=25mm,rmargin=25mm}
%\input{lambdaTeX}

\pagestyle{fancyplain} 
\lfoot{Geni source code}
\cfoot{\thepage}
\rfoot{}

\setlength\parindent{0pt}
\setlength{\fboxsep}{0.1pt}

\renewcommand\FrameHeightAdjust{1pt}


\newenvironment{framedcode}% using default \FrameCommand
  {\MakeFramed {\advance\hsize-\width \FrameRestore}}%
  {\endMakeFramed}

\newenvironment{code}% using default \FrameCommand
  {\VerbatimEnvironment
   \footnotesize
   %\begin{framedcode}
   \begin{Verbatim}
  }%
  {\end{Verbatim} 
   %\end{framedcode}
   \normalsize }

%\lstloadlanguages{Haskell} 
%\lstnewenvironment{code} 
%    {\lstset{}% 
%      \csname lst@SetFirstLabel\endcsname} 
%    {\csname lst@SaveFirstLabel\endcsname} 
%    \lstset{ 
%      basicstyle=\small\ttfamily, 
%      flexiblecolumns=false, 
%      basewidth={0.5em,0.45em}, 
%      literate={-}{{$-$}}1 {+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1 
%               {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1 
%               {->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2 
%               {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2 {\ .}{{$\circ$}}2 
%               {>>}{{>>}}2 {>>=}{{>>=}}2 
%    } 

\newcommand{\jargon}{\textbf}
\newcommand{\natlang}{\textit}
\newcommand{\semexpr}{\texttt}
\long\def\ignore#1{}

\newcommand{\tuple}[1]{\langle #1 \rangle}

\begin{document}
\title{Literate Geni}
\author{Langue et Dialogue\\LORIA}

\maketitle
\tableofcontents

% -------------------------------------------------------------------------
% Overview 
% -------------------------------------------------------------------------

\chapter{Overview}

This is the source code to the GenI generator being adapted to a
literate programming style.  

\section{Core files}

Geni.lhs and Mstate.lhs perform the candidate selection and generation.
They will tend make heavy use of the modules Btypes.lhs and Tags.lhs, in
which we try to encapsulate some basic or generic operations into the
files.

\begin{description}
 \item[Geni.lhs] - parses and formats data for the generator 
 \item[Mstate.lhs] - the chart generator itself (note: substitution,
 adjunction, FS unification are done here, not in Tags.lhs)
 \item[Btypes.lhs] - basic data types 
 \item[Tags.lhs] - TAG specific data types
\end{description}

\section{Optimisation}

In addition to the modules below, chapter \ref{chp:other_optimisations}
will point you to ones which could not be cleanly seperated into
modules.

\begin{description}
 \item[Polarity.lhs] - the polarity automaton optimisation 
 \item[Predictors.lhs] - the now defunct predictors optimisation
\end{description}

\section{User Interface}

We use the WxHaskell toolkit for the Geni user interface.  Geni
can also be used without the GUI if you edit the .genirc file.
We currently visualise our results with Graphviz, a third party graph
visualisation tool.

\begin{description}
 \item[Main.hs] - provides console and batch processing 
 \item[Gui.lhs] - main GUI code 
 \item[Treeprint.lhs] - outputs trees in various formats 
                        (currently as sentences and as graphviz dot
                        files)
 \item[Graphviz.lhs] - interacts with the graphviz drawing tool
\end{description}

\section{Input files}

We use the package \textit{Happy} to create parsers for our various
input files.  Happy is essentially Yacc for Haskell.

\begin{description}
 \item[Cparser.y] parser for command line arguments
 \item[Giparser.y] parser for grammar index files
 \item[Mparser.y] parser for macro files 
 \item[Lparser.y] parser for lexicon files 
 \item[Tparser.y] parser for target semantics files 
\end{description}

We use the package \textit{Alex} to generate a lexer that is common to
all parsers.

\begin{description}
 \item[Lex2.x] code for the common lexer
 \item[ParserLib.hs] data types shared by the lexer and the parsers 
\end{description}

Also of interest are XML grammar files (processed with the HaXml toolkit
) and the Configuration file (.genirc)

\begin{description}
 \item[GrammarXml.lhs] parser for grammar (in adhoc XML format)
 \item[Configuration.lhs] inteprets result of Cparser.y
\end{description}

% -------------------------------------------------------------------------
% future literate notes
% -------------------------------------------------------------------------

% talk about the fact that we use FiniteMap

\part{Core files}

\input{Geni.lhs}       
\input{Mstate.lhs}       
\input{Btypes.lhs}       
\input{Tags.lhs}       

\part{Optimisation}

\input{Polarity.lhs}       
% \input{Predictors.lhs}

\chapter{Other optimisations}
\label{chp:other_optimisations}

Some of the optimisations related to adjunction are integrated into
to the generator.

\section{Semantic filtering}

See section \ref{sec:semfilter}

\section{Ordered adjunction}

See section \ref{sec:ordered_adjunction}

\section{Foot constraint}

See section \ref{sec:foot_constraint}

\part{User interface}

\chapter{Main}
\verbatiminput{Main.hs}

\input{Gui.lhs}
\input{Graphviz.lhs}
\input{Treeprint.lhs}

\part{Input files}

\input{Configuration.lhs}
\input{GrammarXml.lhs}

\end{document}
